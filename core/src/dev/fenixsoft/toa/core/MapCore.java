package dev.fenixsoft.toa.core;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.TimeUtils;
import dev.fenixsoft.toa.managers.LevelManager;
import dev.fenixsoft.toa.managers.TileManager;
import dev.fenixsoft.toa.mapData.Chunk;
import dev.fenixsoft.toa.toolbox.MapGenerator;
import dev.fenixsoft.toa.toolbox.Utils;

import java.io.*;

public class MapCore implements Runnable{

    public Thread thread;

    public static boolean paused = false;
    public static boolean running = false;

    public static int ticks = 0;

    public static final int CHUNK_WIDTH = 32;
    public static final int LEVEL_TILE_SIZE = 8;

    public static final Vector2 CHUNK_SIZE_UNIT = new Vector2(LEVEL_TILE_SIZE * CHUNK_WIDTH, LEVEL_TILE_SIZE * CHUNK_WIDTH);
    public static final Vector2 LEVEL_TILE_UNIT = new Vector2(LEVEL_TILE_SIZE, LEVEL_TILE_SIZE);

    //SIZE IN ROOMS!!!
    public static int LEVEL_HEIGHT = 32;
    public static int LEVEL_WIDTH = 128;

    public static final int OVERWORLD_TILE_SIZE = 16;

    public static final int OVERWORLD_LAYERS = 7;
    public static final int OVERWORLD_SIZE = 512 / CHUNK_WIDTH;

    public static final int TILE_RENDERING_BORDER = 2;

    private static Chunk[] overworldMapData = new Chunk[OVERWORLD_SIZE * OVERWORLD_SIZE * OVERWORLD_LAYERS];

    static short selectedTile = 4;

    //keep track of generated height maps!
    //private final static Map<String,float[]> heightData = new ConcurrentHashMap<>();
    //private final static Map<String,float[]> biomeData = new ConcurrentHashMap<>();

    public static int seed = 0;

    void init(){

        for(int i = 0; i < OVERWORLD_SIZE; i++) {
            for (int j = 0; j < OVERWORLD_SIZE; j++) {
                for (int z = 0; z < OVERWORLD_LAYERS; z++) {

                    overworldMapData[i +
                            (j * OVERWORLD_SIZE) +
                            (z *
                                    (OVERWORLD_SIZE * OVERWORLD_SIZE)
                            )] =  MapGenerator.generateData(i,j);

                }
            }
        }



        System.out.println("Chunks loaded");

    }

    public static int generateLevel(int xPos){
        return LevelManager.generateLevel(xPos, LEVEL_HEIGHT, LEVEL_WIDTH);
    }

    @Override
    public void run() {
        init();

        long lastTime = TimeUtils.nanoTime();
        double nsPerTick = 1000000000D / 60D;

        int counter = 0;

        long lastTimer = TimeUtils.millis();
        double delta = 0;

        while (running) {

            if(!paused) {

                long now = TimeUtils.nanoTime();
                delta += (now - lastTime) / nsPerTick;
                lastTime = now;

                while (delta >= 1) {
                    counter++;
                    tick();
                    delta -= 1;
                }

                try {
                    Thread.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                if (TimeUtils.millis() - lastTimer >= 1000) {
                    lastTimer += 1000;
                    //System.out.println(ticks + " MapCore ticks");
                    ticks = counter;
                    counter = 0;
                }
            }
        }

        stop();

    }

    public synchronized void start(){
        thread = new Thread(this);
        running = true;
        thread.start();

        seed = 0;

    }

    public synchronized void stop(){
        try {
            thread.interrupt();
            thread.join();
        } catch (InterruptedException e) {
            //TODO autogenerated block
        }
    }

    public static void tick() {

        //int posX = (int) MainCore.camera.getPosition().x - ((w / 2) / TileSize);
        //int posY = (int) MainCore.camera.getPosition().y - ((h / 2) / TileSize);

        int posX = (int) MainCore.camera.getPosition().x / CHUNK_WIDTH;
        int posY = (int) MainCore.camera.getPosition().y / CHUNK_WIDTH;

        /*
        for(int x = posX - (CHUNK_VIEW_DISTANCE); x < posX + (CHUNK_VIEW_DISTANCE); x++) {
            for(int y = posY - (CHUNK_VIEW_DISTANCE); y < posY + (CHUNK_VIEW_DISTANCE); y++) {

                if(mapDataB[((x + (y * CHUNK_LOAD_DISTANCE) + (0 * (CHUNK_LOAD_DISTANCE * CHUNK_LOAD_DISTANCE))))] != null) {

                    Chunk chunk = mapDataB[((x + (y * CHUNK_LOAD_DISTANCE) + (0 * (CHUNK_LOAD_DISTANCE * CHUNK_LOAD_DISTANCE))))];

                    if (!chunk.getRender()) {
                        chunk.setRender(true);
                        OverworldRenderer.getChunksList().add(chunk);
                    }
                }

            }
        }

        for(Chunk chunk: OverworldRenderer.getChunksList()) {

            int x = (int)chunk.getPosition().x;
            int y = (int)chunk.getPosition().y;

            if(x < posX - CHUNK_VIEW_DISTANCE
                    || x > posX + CHUNK_VIEW_DISTANCE
                    || y < posY - CHUNK_VIEW_DISTANCE
                    || y > posY + CHUNK_VIEW_DISTANCE) {

                if(chunk.getRender()) {
                    chunk.setRender(false);
                    OverworldRenderer.getChunksList().remove(chunk);
                }



            }
        }
        */

            //editTerrain(posX, posZ);

    }

    /*
    public static void editTerrain(int posX, int posZ) {

        if(InputHandler.isKeyPressed(Keyboard.KEY_I)){
            Mouse.setClipMouseCoordinatesToWindow(true);
            Mouse.setGrabbed(true);
        }

        if(InputHandler.isKeyPressed(Keyboard.KEY_SUBTRACT) && selectedTile - 1 >= 1){
            selectedTile--;
            System.out.println("tile is " + selectedTile);
        }

        if(InputHandler.isKeyPressed(Keyboard.KEY_ADD) && selectedTile + 1 <= TileManager.TILE_LIST.size()-1){
            selectedTile++;
            System.out.println("tile is " + selectedTile);
        }

        if(InputHandler.isKeyPressed(Keyboard.KEY_F5)){

            try {
                saveWorld(posX, posZ);
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }

        if(Mouse.isButtonDown(1)) {

            Vector3f collisionPointInMap = RenderCore.camera.ray.checkRayInMap(10, true, true);

            if(collisionPointInMap != null){

                int X = (int) collisionPointInMap.x;
                int Y = (int) collisionPointInMap.y;
                int Z = (int) collisionPointInMap.z;

                System.out.println("mouse clicked in [" + collisionPointInMap + "]");

                setTile(X, Y, Z, selectedTile);

            }

        }

        if(Mouse.isButtonDown(0)) {

            Vector3f collisionPointInMap = RenderCore.camera.ray.checkRayInMap(10, false, true);

            if(collisionPointInMap != null){

                int X = (int) collisionPointInMap.x;
                int Y = (int) collisionPointInMap.y;
                int Z = (int) collisionPointInMap.z;

                System.out.println("mouse clicked in [" + collisionPointInMap + "]");

                setTile(X, Y, Z, (short) 0);

            }

        }

    }
    */

    public static boolean loadChunk(int x, int y, int z) {

        File fileDir = new File("saves/" + x + "_" + y + "_" + z + ".Chunk");

        if(fileDir.exists()) {

            short[] data = new short[CHUNK_WIDTH*CHUNK_WIDTH];

            int airBlocks = 0;

            String file = Utils.loadFileAsString("saves/" + x + "_" + y + "_" + z + ".Chunk");

            String[] lines = file.split("_");

            for (int i = 0; i < data.length; i++) {

                data[i] = (short) Utils.parseInt(lines[i]);
                if (data[i] == 0){
                    airBlocks++;
                }

            }

            Chunk chunk = new Chunk(data);

            //mapData.put("" + x + "_" + y + "_" + z + "", chunk);

            System.out.println("loaded the Chunk save file (" + x + "_" + y + "_" + z + ")");

            return true;

        }

        return false;
    }

    // TODO: saving and loading... BROKEN!!!
    /*
    public static void saveWorld(int posX, int posZ) throws IOException {

        for(int x = posX - (CHUNK_LOAD_DISTANCE); x < posX + (CHUNK_LOAD_DISTANCE); x++) {
            for(int z = posZ - (CHUNK_LOAD_DISTANCE); z < posZ + (CHUNK_LOAD_DISTANCE); z++) {
                for(int y =  0; y < OVERWORLD_LAYERS ; y++) {
                    saveChunk(x, y, z);
                }
            }
        }

    }

    public static void saveChunk(int x, int y, int z) throws IOException {

        Chunk chunk = mapData.get("" + x + "_" + y + "_" + z + "");

        if(chunk != null) {
            if(!chunk.getSaved()) {

                PrintStream out = new PrintStream(new FileOutputStream("saves/" + x + "_" + y + "_" + z + ".Chunk"));
                ObjectOutputStream ou = new ObjectOutputStream(out);

                short[] data = chunk.getTiles();

                for (short type: data) {

                    ou.writeInt(type);

                }

                ou.close();

                chunk.setSaved();

                System.out.println("updated the Chunk save file (" + x  + "_" + y + "_" + z + ")");

            }
        }

    }
    */

    public static void setOverworldTile(int xPos, int yPos, int zPos, short value) {
        float xTile, yTile;

        xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
        yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);

        float xChunk, yChunk;
        xChunk = (xPos / (float)CHUNK_WIDTH);
        yChunk = (yPos / (float)CHUNK_WIDTH);

        if(xChunk < 0) {
            xChunk = (float) Math.floor(xChunk);
        }

        if(yChunk < 0) {
            yChunk = (float) Math.floor(yChunk);
        }

        if(xPos <=-1 || yPos <=-1
        || xPos >= OVERWORLD_SIZE * CHUNK_WIDTH
        || yPos >= OVERWORLD_SIZE * CHUNK_WIDTH){
            return;
        }

        if(overworldMapData[ (((int)xChunk + ((int)yChunk * OVERWORLD_SIZE) + (zPos * (OVERWORLD_SIZE * OVERWORLD_SIZE))))] != null) {
            //System.out.println("Chunk in [" + (int)xChunk + "," + (int)yChunk + "," + (int)zChunk +"]");
            overworldMapData[((int)xChunk + ((int)yChunk * OVERWORLD_SIZE) + (zPos * (OVERWORLD_SIZE * OVERWORLD_SIZE)))].
                setTile((int) xTile, (int) yTile, value);
        }

    }

    public static short getOverworldTile(int xPos, int yPos, int zPos) {
        float xTile, yTile;

        xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
        yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);

        float xChunk, yChunk;
        xChunk = (xPos / (float)CHUNK_WIDTH);
        yChunk = (yPos / (float)CHUNK_WIDTH);

        if(xChunk < 0) {
            xChunk = (float) Math.floor(xChunk);
        }

        if(yChunk < 0) {
            yChunk = (float) Math.floor(yChunk);
        }

        if(xPos <=-1 || yPos <=-1
        || xPos >= OVERWORLD_SIZE * CHUNK_WIDTH
        || yPos >= OVERWORLD_SIZE * CHUNK_WIDTH){
            return 0;
        }

        if(overworldMapData[ (((int)xChunk + ((int)yChunk * OVERWORLD_SIZE) + (zPos * (OVERWORLD_SIZE * OVERWORLD_SIZE))))] != null) {
            return overworldMapData[((int)xChunk + ((int)yChunk * OVERWORLD_SIZE) + (zPos * (OVERWORLD_SIZE * OVERWORLD_SIZE)))].
                getTile((int)xTile, (int)yTile);
        }
        return 0;
    }

    public static void setLevelTile(int xPos, int yPos, short value) {
        float xTile, yTile;

        xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
        yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);

        float xChunk, yChunk;
        xChunk = (xPos / (float)CHUNK_WIDTH);
        yChunk = (yPos / (float)CHUNK_WIDTH);

        if(xChunk < 0) {
            xChunk = (float) Math.floor(xChunk);
        }

        if(yChunk < 0) {
            yChunk = (float) Math.floor(yChunk);
        }

        if(xPos <=-1 || yPos <=-1
        || xPos >= LEVEL_WIDTH * CHUNK_WIDTH
        || yPos >= LEVEL_HEIGHT * CHUNK_WIDTH){
            return;
        }

        if(LevelManager.getLevelMapData()[(int)xChunk + ((int)yChunk * LEVEL_WIDTH)] != null) {
            //System.out.println("Chunk in [" + (int)xChunk + "," + (int)yChunk + "," + (int)zChunk +"]");
            LevelManager.getLevelMapData()[(int)xChunk + ((int)yChunk * LEVEL_WIDTH)].
                    setTile((int) xTile, (int) yTile, value);
        }

    }

    public static short getLevelTile(int xPos, int yPos) {
        float xTile, yTile;

        xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
        yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);

        float xChunk, yChunk;
        xChunk = (xPos / (float)CHUNK_WIDTH);
        yChunk = (yPos / (float)CHUNK_WIDTH);

        if(xChunk < 0) {
            xChunk = (float) Math.floor(xChunk);
        }

        if(yChunk < 0) {
            yChunk = (float) Math.floor(yChunk);
        }

        if(xPos <=-1 || yPos <=-1
        || xPos >= LEVEL_WIDTH * CHUNK_WIDTH
        || yPos >= LEVEL_HEIGHT * CHUNK_WIDTH){
            return 13;
        }

        if(LevelManager.getLevelMapData()[(int)xChunk + ((int)yChunk * LEVEL_WIDTH)] != null) {
            //System.out.println("Chunk in [" + (int)xChunk + "," + (int)yChunk + "]");
            return LevelManager.getLevelMapData()[(int)xChunk + ((int)yChunk * LEVEL_WIDTH)].
                    getTile((int)xTile, (int)yTile);
        }

        return 13;
    }

    public static int getGroundInLevel(int xPos, int yPos){
        int result = 0;

        for (int i = yPos; i >= 0; i--) {
            short data = getLevelTile(xPos, i);

            if(TileManager.TILE_LIST.get(data).isSolid()){
                result = i + 1;
                System.out.println("checked " + result + " in a " + data + " block type");
                break;
            }
        }

        return result;
    }

    /*
    public static Chunk getMapData(int xPos, int yPos, int zPos) {
        return mapData.get("" + xPos +"_"+ yPos +"_"+ zPos + "");
    }

    public static short[] getTileData(int xPos, int yPos, int zPos){
        return mapData.get("" + xPos +"_"+ yPos +"_"+ zPos + "").getTiles();
    }
    */

    /*
    public static void generateData(int x, int y){

        float[] values = heightData.get("" + x + "_" + y + "");
        float[] biomes = biomeData.get("" + x + "_" + y + "");

        if (values == null || biomes == null) {

            biomes = HeightGenerator.GenerateNoiseMap((x * CHUNK_WIDTH) + seed, (y * CHUNK_WIDTH) + seed);
            values = HeightGenerator.GenerateHeightMap((x * CHUNK_WIDTH) + seed, (y * CHUNK_WIDTH) + seed, biomes);

            heightData.put("" + x + "_" + y + "", values);
            biomeData.put("" + x + "_" + y + "", biomes);

        }
        else{

            for (int z = 0; z < OVERWORLD_LAYERS; z++) {

                Chunk chunk = mapData.get("" + x + "_" + y + "_" + z + "");

                System.out.println("Chunk in [" + x + "," + y + "]" + " in the layer " + z);

                if (chunk == null) {

                    if (!loadChunk(x, y, z)) {
                        Chunk data = MapGenerator.generateData(x, y, values, biomes);

                        mapData.put("" + x + "_" + y + "_" + z + "", data);
                    }

                }

            }

        }

    }
    */

    public static boolean isSolid(int x, int y){

        if(getOverworldTile(x, y, 0) != 0)
            return true;

        return false;
    }

    /*
    public static Map<String,Chunk> getMapData() {
        return mapData;
    }

    public static Map<String,float[]> getHeightData() {
        return heightData;
    }

    public static Map<String,float[]> getBiomeData() {
        return biomeData;
    }
    */

}
